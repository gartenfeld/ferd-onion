var fs = require('fs')
  , htmlparser = require('htmlparser2')
  , soupselect = require('cheerio-soupselect')
  , curl = require('curlrequest')
  , decode = require('./entities');

/**
 * Make a request.
 */

exports.request = function (options, callback) {
    if (arguments.length === 1) {
        var defaults = options;
        return function (options, callback) {
            if (typeof options === 'function') {
                callback = options;
                options = {};
            } else if (typeof options === 'string') {
                options = { url: options };
            }
            for (var key in defaults) {
                if (typeof options[key] === 'undefined') {
                    options[key] = defaults[key];
                }
            }
            exports.request.call(this, options, callback);
        };
    }

    if (typeof options !== 'object') {
        options = { url: options };
    }

    var scope = options.scope || {};

    curl.request(options, function (err, data) {
        var parser = new htmlparser.Parser(new htmlparser.DefaultHandler(function (err, dom) {
            callback.call(scope, err, function (selector, context) {
                return bindToCollection(soupselect.select(context || dom, selector));
            }, data);
        }, { verbose: true, ignoreWhitespace: true }));
        if (err) {
            return callback.call(scope, err, null, data);
        } else {
            parser.write(data);
            parser.done();
        }
    });
};

/**
 * Add some helper methods to DOM elements.
 */

function bindToElement(result) {
    var self = this, hasChildren, x, last;

    if (result.children) {
        bindToCollection(result.children);
        last = result.children.length - 1;
        hasChildren = true;
    }

    result.find = function (selector) {
        return hasChildren ? bindToCollection(soupselect.select(result.children, selector)) : null;
    }

    result.__defineGetter__('rawtext', function () {
        var text = '';
        if (hasChildren) {
            for (x = 0; x <= last; x++) {
                if (result.children[x].type === 'text') {
                    text += result.children[x].data;
                }
            }
        }
        return text;
    });

    result.__defineGetter__('text', function () {
        var text = '';
        if (hasChildren) {
            for (x = 0; x <= last; x++) {
                if (result.children[x].type === 'text') {
                    text += ' ' + result.children[x].data.trim();
                } else if (result.children[x].name === 'br') {
                    text += '\n';
                }
            }
        }
        return decode(text).trim().replace(/  +/g, ' ');
    });

    result.__defineGetter__('striptags', function striptags (res) {
        if (!res) res = result;
        var text = '';
        if (res.children && res.children.length > 0) {
            for (var i = 0, l = res.children.length; i < l; i++) {
                if (res.children[i].type === 'text') {
                    text += res.children[i].data;
                } else if (res.children[i].type === 'tag') {
                    text += striptags(res.children[i]);
                }
            }
        }
        return text;
    });

    result.__defineGetter__('fulltext', function fulltext (res) {
        if (!res) res = result;
        var text = '';
        if (res.children && res.children.length > 0) {
            for (var i = 0, l = res.children.length; i < l; i++) {
                if (res.children[i].type === 'text') {
                    text += ' ' + res.children[i].data.trim();
                } else if (res.children[i].name === 'br') {
                    text += '\n';
                } else if (res.children[i].type === 'tag') {
                    text += ' ' + fulltext(res.children[i]);
                }
            }
        }
        return decode(text).trim().replace(/  +/g, ' ');
    });

    result.__defineGetter__('innerHTML', function innerHTML (res) {
        if (!res) res = result;
        var text;
        switch (res.type) {
            case 'tag':
            case 'script':
            case 'style':
                text = '<' + res.name + '>';
                if (res.children && res.children.length > 0) {
                    for (var i = 0, l = res.children.length; i < l; i++) {
                        text += innerHTML(res.children[i]);
                    }
                }
                text += '</' + res.name + '>';
                break;
            case 'comment':
                text = '<!--' + res.name + '-->';
                break;
            case 'text':
                text = res.data.trim();
                break;
        }
        return text;
    });

    return result;
}

/**
 * Add some helper methods to DOM collections.
 */

function bindToCollection(result) {
    var len = result.length;

    result.find = function (selector) {
        return bindToCollection(soupselect.select(result, selector));
    }

    result.nth = function (n) {
        return !len || n >= len ? null : bindToElement(result[n]);
    };

    result.last = function () {
        return this.nth(len - 1);
    };

    result.first = function () {
        return this.nth(0);
    }

    result.each = function (attrib, callback) {
        if (typeof attrib !== 'function') {
            for (var i = 0, l = result.length; i < l; i++) {
                if (!results[i].attribs || !(attrib in result[i].attribs)) {
                    continue;
                }
                if (false === callback(result[i].attribs[attrib], i)) {
                    break;
                }
            }
        } else {
            callback = attrib;
            for (var i = 0, l = result.length; i < l; i++) {
                if (false === callback(bindToElement(result[i]), i)) {
                    break;
                }
            }
        }
    };

    return result;
};

/**
 * Export curl helpers.
 */

exports.curl = curl.request;
exports.concurrent = curl.concurrent;

